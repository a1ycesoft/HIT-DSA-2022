第一次：
	BST方案一(查找成功/失败的平均查找长度)：512.5 512.999
	BST方案二(查找成功/失败的平均查找长度)：13.04 14.0263
	折半查找(查找成功/失败的平均查找长度)：9.01172 10.002
第二次：
	BST方案一(查找成功/失败的平均查找长度)：512.5 512.999
	BST方案二(查找成功/失败的平均查找长度)：12.3389 13.3259
	折半查找(查找成功/失败的平均查找长度)：9.01172 10.002
第三次：
	BST方案一(查找成功/失败的平均查找长度)：512.5 512.999
	BST方案二(查找成功/失败的平均查找长度)：12.9814 13.9678
	折半查找(查找成功/失败的平均查找长度)：9.01172 10.002

	BST查找和折半查找的时间复杂度都是O(logn),但如果用顺序序列建树就会导致BST不能够满足平衡性，导致性能下降，比如本次实验，用顺序序列建树的时候，就会退化形成一条链，导致每次查找后面的数据性能特别差。如果给的数字不是规律的，而是随机的，如方案二，我们发现他的平均查找时间性能和折半查找时间性能相差较小。
	因此对于随机数据，就平均性能而言，BST 的查找与折半查找差不多。